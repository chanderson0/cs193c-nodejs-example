<!doctype html>
<html>
<head>
  <meta charset="utf-8">

  <title>SocketIO Example</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <link rel="stylesheet" href="css/reset.css">
  <style>
    html, body { height: 100%; }

    body {
      text-align: center;
      background: #eee;
    }

    div#content {
      position: absolute;
      top: 50%;
      left: 50%;

      height: 600px;
      margin-top: -300px;

      width: 600px;
      margin-left: -300px;

      background: #fff;
      box-shadow: 2px 2px 4px #aaa;
    }
  </style>
</head>

<body>

<div id="content"></div>

<script src="/socket.io/socket.io.js"></script>
<script src="/js/raphael-min.js"></script>
<script>
  // Our SVG canvas.
  var paper = Raphael("content", 600, 600);

  // Connect to the socket.io server.
  var socket = io.connect('/raphael');

  // Data. Nickname is our server-assigned identifier, objects keeps 
  // track of the RaphaelJS representations of room members with keys
  // that are their nicknames, and positions maintains the server's 
  // representation of their positions.
  var nickname = 0;
  var objects = {};
  var positions = {};

  // Functions for drag-and-drop.
  var start = function () {
    // storing original coordinates
    this.ox = this.attrs.x;
    this.oy = this.attrs.y;
  },
  move = function (dx, dy) {
    // Don't move if we're going off the screen.
    var nx = this.ox + dx;
    var ny = this.oy + dy;

    // Can't go off the screen;
    nx = Math.min(Math.max(nx, 0), paper.width - this.attrs.width);
    ny = Math.min(Math.max(ny, 0), paper.height - this.attrs.height);

    // move will be called with dx and dy
    this.attr({x: nx, y: ny});

    // Update our position representation, and notify the server. We floor
    // our position in order to minimize transport costs. In other words,
    // sending a bunch of decimal places isn't worth it.
    positions[nickname] = { 
      x: Math.floor(this.attrs.x), 
      y: Math.floor(this.attrs.y) 
    };
    socket.emit('move', positions[nickname]);
  },
  up = function() {
    // Nothing.
  };

  // This is a special event that gets fired only on first joining. We
  // get some initialization data from the server so we can get up and going.
  socket.on('me-join', function (data) {
    nickname = data.nickname;
    positions = data.positions;
    positions[nickname] = data.position;

    // Make an object for myself.
    objects[nickname] = paper.rect(positions[nickname].x, positions[nickname].y, 50, 50, 10)
      .attr({fill: '#990000'}); // Cardinal, of course.
    objects[nickname].drag(move, start, up);

    // Make an object for everyone.
    for (var n in positions) {
      if (n == nickname) continue;

      data = positions[n];
      newguy = paper.rect(data.x, data.y, 50, 50)
        .attr({fill: '#232F5E'});
      objects[n] = newguy;
      newguy.toBack();
    }
  });

  // Someone joined this room, ignore if it's us.
  socket.on('join', function (data) {
    if (data.nickname == nickname) return;

    // Someone joined, make an object for them.
    newguy = paper.rect(data.position.x, data.position.y, 50, 50)
      .attr({fill: '#232F5E'});
    objects[data.nickname] = newguy;

    // Keep the newcomer in the background so we don't overlap.
    newguy.toBack();

    positions[data.nickname] = data.position;
  });

  // Someone moved - it could have been us, so we ignore this message
  // if it really was us that moved.
  socket.on('move', function (data) {
    if (data.nickname == nickname) return;

    // Someone moved, move them.
    objects[data.nickname].attr(data.position);
    positions[data.nickname] = data.position;
  });

  // Someone left, remove them.
  socket.on('leave', function(data) {
    objects[data.nickname].remove();
    delete positions[data.nickname];
  });
</script>

</body>
</html>
